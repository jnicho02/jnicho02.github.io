<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>
    Data tiles in Leaflet</title>
    <link rel="stylesheet" href="https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap.css">
    <link href="/stylesheets/normalize.css" rel="stylesheet" /><link href="/stylesheets/all.css" rel="stylesheet" />
    <script src="/javascripts/all.js"></script>
  </head>

  <body class="x2015 x2015_06 x2015_06_data-tiles-in-leaflet">
        <nav class="navbar navbar-fixed-top navbar-dark bg-inverse">
      <a class="navbar-brand" href="/"><img src="/images/jez.jpg" width="80em" class="img-circle pull-left" alt="Photo of Jez Nicholson"></a>
      <ul class="nav navbar-nav">
        <li class="nav-item"><a class="nav-link" href="/about/">About</a></li>
        <li class="nav-item"><a class="nav-link" href="/tags/">Tags</a></li>
      </ul>
    </nav>

    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <div class="container-fluid">
      <h1>Data tiles in Leaflet</h1>
      <p>Here is a little something i've been playing with. After the first flush of plotting points on a Leaflet map I soon realised that things can get quite slow. I've been building a tile-based data server which is hooked in to the map tile calls in the javascript. It isn't an original thought (i'll add in links to original references when I find them) but i've taken it a bit further than other people have.</p>

<p>This post is not complete, I will be expanding it.</p>

<p>​​A short video…</p>

<p>https://youtu.be/2PCPa8PuHng</p>

<p>Leaflet is very quick and easy to get a map up and running.</p>

<p><img src="/images/basic_map.png" alt="/images/basic_map.png" /></p>

<p>If you return points from your data server as geojson they can be hooked straight in
<img src="/images/some_points.png" alt="/images/some_points.png" /></p>

<p>That is a bit ugly, but the <a href="https://github.com/Leaflet/Leaflet.markercluster">Leaflet.markerclusterer</a> comes to the rescue</p>

<p><img src="/images/clusters.png" alt="/images/clusters.png" /></p>

<p>If you don't have an awful lot of data then you could simply load all of it from a single geojson file. We have 35000+ plaques on Open Plaques so passing the entire database is not an option.</p>

<p>The standard functionality is to trigger a bounding box query with <a href="http://jasonsanford.github.io/leaflet-vector-layers/">leaflet-vector-layers</a> or similar. Top-left and  bottom-right coordinates are sent as parameters in whatever url structure you tell it.</p>

<p><img src="/images/bounding_box.png" alt="/images/bounding_box.png" /></p>

<p>A bounding box is a very simple SQL query</p>

<pre><code>SELECT * from plaques
WHERE latitude between (a and b)
AND longitude between (x and y)
</code></pre>

<p>And if you index on 'latitude, longitude' then it should run pretty quick.</p>

<p>However, once you do a big zoom then you'll be doing a correspondingly large SQL query :( Large numbers of records could be returned. In our case this pushed the http call past the Heroku 12 second maximum and it assumed that our server had hung.</p>

<p><img src="/images/big_zoom.png" alt="/images/big_zoom.png" /></p>

<p>A slippymap is made of tiles…</p>

<p><img src="/images/tiles.png" alt="/images/tiles.png" /></p>

<p>It is fairly trivial to convert from tile number -&gt; coordinates and vice versa. The formulae are published on the <a href="http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">OpenStreetMap Wiki Slippy_map_tilenames</a></p>

<p><img src="/images/do_the_math.png" alt="/images/do_the_math.png" /></p>

<p><img src="/images/tiled_calls.png" alt="/images/tiled_calls.png" /></p>

<p><img src="/images/one_data_tile.png" alt="/images/one_data_tile.png" /></p>

<p>Big zoom. Lots of little SQL queries :)</p>

<p><img src="/images/big_zoom_tiled.png" alt="/images/big_zoom_tiled.png" /></p>

<p>Standardize on one zoom level for the data calls. This will reduce the number of calls made and enable us to cache the results.</p>

<p><img src="/images/data_at_one_level.png" alt="/images/data_at_one_level.png" /></p>

<p>Speed Improvements</p>

<ul>
  <li>Only query at one zoom level</li>
  <li>Streamline the SQL</li>
  <li>Don’t repeat calls, keep a list</li>
  <li>Cache json on the server with Redis or memcached</li>
  <li>Dump to files…</li>
</ul>

<p><img src="/images/cached_json.png" alt="/images/cached_json.png" /></p>

<p>What's left?</p>

<ul>
  <li>Country level view fires a lot of calls</li>
  <li>Can flood the server</li>
  <li>Restrict the maximum map zoom level?</li>
  <li>Store aggregated counts</li>
</ul>

<p>Alternatives?
* http://agentscript.org/docs/data.tile.html
* http://bl.ocks.org/glenrobertson/6203331</p>

    </div>

    <div class="container-fluid" name="tags">
        <a href="/tags/ideas/">
        <span class="label label-pill label-info pull-left">ideas</span>
        </a>
        <a href="/tags/geo/">
        <span class="label label-pill label-primary pull-left">geo</span>
        </a>
    </div>
    <div class="container">
  <span>It's All In The Game blog (c) 2005-16 by Jez Nicholson</span>
</div>
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-5854204-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/js/bootstrap.js"></script> 


  </body>
</html>
