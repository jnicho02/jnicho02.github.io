<p>Here is a little something i've been playing with. After the first flush of plotting points on a Leaflet map I soon realised that things can get quite slow. I've been building a tile-based data server which is hooked in to the map tile calls in the javascript. It isn't an original thought (i'll add in links to original references when I find them) but i've taken it a bit further than other people have.</p>

<p>This post is not complete, I will be expanding it.</p>

<p>​​A short video…</p>

<p>https://youtu.be/2PCPa8PuHng</p>

<p>Leaflet is very quick and easy to get a map up and running.</p>

<p><img src="/images/basic_map.png" alt="/images/basic_map.png" /></p>

<p>If you return points from your data server as geojson they can be hooked straight in
<img src="/images/some_points.png" alt="/images/some_points.png" /></p>

<p>That is a bit ugly, but the <a href="https://github.com/Leaflet/Leaflet.markercluster">Leaflet.markerclusterer</a> comes to the rescue</p>

<p><img src="/images/clusters.png" alt="/images/clusters.png" /></p>

<p>If you don't have an awful lot of data then you could simply load all of it from a single geojson file. We have 35000+ plaques on Open Plaques so passing the entire database is not an option.</p>

<p>The standard functionality is to trigger a bounding box query with <a href="http://jasonsanford.github.io/leaflet-vector-layers/">leaflet-vector-layers</a> or similar. Top-left and  bottom-right coordinates are sent as parameters in whatever url structure you tell it.</p>

<p><img src="/images/bounding_box.png" alt="/images/bounding_box.png" /></p>

<p>A bounding box is a very simple SQL query</p>

<pre><code>SELECT * from plaques
WHERE latitude between (a and b)
AND longitude between (x and y)
</code></pre>

<p>And if you index on 'latitude, longitude' then it should run pretty quick.</p>

<p>However, once you do a big zoom then you'll be doing a correspondingly large SQL query :( Large numbers of records could be returned. In our case this pushed the http call past the Heroku 12 second maximum and it assumed that our server had hung.</p>

<p><img src="/images/big_zoom.png" alt="/images/big_zoom.png" /></p>

<p>A slippymap is made of tiles…</p>

<p><img src="/images/tiles.png" alt="/images/tiles.png" /></p>

<p>It is fairly trivial to convert from tile number -&gt; coordinates and vice versa. The formulae are published on the <a href="http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">OpenStreetMap Wiki Slippy_map_tilenames</a></p>

<p><img src="/images/do_the_math.png" alt="/images/do_the_math.png" /></p>

<p><img src="/images/tiled_calls.png" alt="/images/tiled_calls.png" /></p>

<p><img src="/images/one_data_tile.png" alt="/images/one_data_tile.png" /></p>

<p>Big zoom. Lots of little SQL queries :)</p>

<p><img src="/images/big_zoom_tiled.png" alt="/images/big_zoom_tiled.png" /></p>

<p>Standardize on one zoom level for the data calls. This will reduce the number of calls made and enable us to cache the results.</p>

<p><img src="/images/data_at_one_level.png" alt="/images/data_at_one_level.png" /></p>

<p>Speed Improvements</p>

<ul>
  <li>Only query at one zoom level</li>
  <li>Streamline the SQL</li>
  <li>Don’t repeat calls, keep a list</li>
  <li>Cache json on the server with Redis or memcached</li>
  <li>Dump to files…</li>
</ul>

<p><img src="/images/cached_json.png" alt="/images/cached_json.png" /></p>

<p>What's left?</p>

<ul>
  <li>Country level view fires a lot of calls</li>
  <li>Can flood the server</li>
  <li>Restrict the maximum map zoom level?</li>
  <li>Store aggregated counts</li>
</ul>

<p>Alternatives?
* http://agentscript.org/docs/data.tile.html
* http://bl.ocks.org/glenrobertson/6203331</p>
